2020-12-10:
在服务器上做实验，把outbox单独拆了一个进程
用4个进程处理，一个进程做outbox
4000个flow用了139s， 28.76 flow/s

看来在笔记本上测试，确实是程序性能不够了，不是mysql或者rabbitmq阻塞，观察到mysql在4个进程处理的时候cpu的使用率是70-80
所以如果要做优化的，需要调查的问题是，为什么程序用了这么多cpu

asyncio maybe

另外，profile那里有些问题，需要处理一下

2020-12-08:
观察到使用 sys.setswitchinterval(0.001) 似乎要快一点，但是当我同时浏览网页时（有负载时）就和默认没有区别了。
所以，可能是我的笔记本性能不足，同时有一个问题，计算量在哪里，大部分应该是IO操作。


2020-12-07:
sqlalchemy 用的时间比我想象的要多

68457 function calls (66423 primitive calls) in 0.428 seconds

   Ordered by: cumulative time
   List reduced from 1004 to 30 due to restriction <30>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        9    0.001    0.000    0.429    0.048 ..\myflow\flowengine\engine.py:136(one_step)
        9    0.000    0.000    0.340    0.038 ..\myflow\flowengine\engine.py:30(_process_node)
       70    0.000    0.000    0.242    0.003 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\engine\base.py:946(execute)
       70    0.000    0.000    0.242    0.003 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\sql\elements.py:296(_execute_on_connection)
       70    0.001    0.000    0.241    0.003 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\engine\base.py:1082(_execute_clauseelement)
       49    0.000    0.000    0.228    0.005 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\orm\query.py:3498(__iter__)
       49    0.001    0.000    0.209    0.004 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\orm\query.py:3523(_execute_and_instances)
       70    0.002    0.000    0.195    0.003 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\engine\base.py:1189(_execute_context)
       71    0.001    0.000    0.179    0.003 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\MySQLdb\cursors.py:171(execute)
       70    0.000    0.000    0.178    0.003 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\engine\default.py:592(do_execute)
       71    0.001    0.000    0.173    0.002 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\MySQLdb\cursors.py:316(_query)
       71    0.000    0.000    0.162    0.002 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\MySQLdb\connections.py:255(query)
       71    0.161    0.002    0.161    0.002 {function Connection.query at 0x000001BB024725E0}
       25    0.001    0.000    0.132    0.005 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\orm\query.py:3403(one_or_none)
        9    0.001    0.000    0.124    0.014 ..\myflow\flowengine\dao.py:167(node_state_from_database)
        6    0.000    0.000    0.087    0.014 ..\myflow\flowengine\dao.py:248(node_from_database)
       16    0.000    0.000    0.069    0.004 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\orm\query.py:3439(one)
        9    0.000    0.000    0.067    0.007 ..\myflow\flowengine\dao.py:302(check_if_flow_state_valid)
       12    0.001    0.000    0.061    0.005 ..\myflow\flowengine\dao.py:207(_set_ioput_node)
        7    0.000    0.000    0.059    0.008 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\orm\query.py:3897(update)
        7    0.000    0.000    0.059    0.008 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\orm\persistence.py:1693(exec_)
        6    0.000    0.000    0.058    0.010 ..\myflow\flowengine\dao.py:269(update_node_database)
       58    0.000    0.000    0.044    0.001 <string>:1(<lambda>)
       58    0.001    0.000    0.044    0.001 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\sql\elements.py:412(compile)
        6    0.000    0.000    0.044    0.007 ..\myflow\flowengine\dao.py:385(commit)
        6    0.000    0.000    0.044    0.007 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\orm\session.py:1008(commit)
       58    0.000    0.000    0.043    0.001 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\sql\elements.py:478(_compiler)
     10/7    0.000    0.000    0.043    0.006 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\orm\session.py:501(commit)
       58    0.001    0.000    0.043    0.001 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\sql\compiler.py:527(__init__)
       58    0.000    0.000    0.042    0.001 D:\WorkSpace\Development\Anaconda2020\lib\site-packages\sqlalchemy\sql\compiler.py:274(__init__)

2020-11-30:
简单测试一下单线程能力，发送10000个dummy任务
笔记本 i5 2核, 25%cpu
消息和flow创建阶段，rabbitmq 55-60 flow 每秒
运行阶段，rabbitmq 50-70 node 每秒 50-60 task 每秒
综合 4 flow 每秒

增加到4个线程并行看看效果,发送2000个任务，并且把任务发送移到引擎启动的后面
用了6分钟45秒
综合 5 flow 每秒， cpu使用率提升到了40-50

增加engine线程到8， 和发送任务线程4
反而变慢了，也就是说线程切换的消耗现在更大
用了8分钟

所有线程改成2个，启动两个进程
cpu利用率上去了，rabbitmq 管理页面消息的吞吐看起来也上去了
但是处理2000个flow用了10分钟，为什么呢

测试只跑一个进程，用的时间少 7分20秒
    有没有可能是因为，outbox锁的问题

发现了下面的异常，有两个事务同时update 82648这个节点。难道是rabbitmq发了两个出去
(MySQLdb._exceptions.OperationalError) (1213, 'Deadlock found when trying to get lock; try restarting transaction')
[SQL: UPDATE node SET state=%s WHERE node.id = %s]
[parameters: ('working', 82648)]
(Background on this error at: http://sqlalche.me/e/13/e3q8)

从outbox堆积的情况来看，这里是一个系统瓶颈


2020-11-25:
outbox 模式跑起来了

2020-11-23:
之前的mysql版本有些低，弄个maria
docker run --name myflow -v /opt/zhangyang/mysql/db2:/var/lib/mysql -p 3306:3307 -e MYSQL_ROOT_PASSWORD=zhang -d mariadb
docker run -it --rm mariadb mysql -h10.19.17.188 -P3307 -uroot -pzhang

2020-11-20:
数据库异常是sqlalchemy释放的时候，释放其他线程里面的session，造成的。所以需要在线程用完session的时候，关闭线程。
检查状态的时，不读取work_data列，减少传输的量
整理代码

2020-11-13:
第一个flow跑通了，但是还有异常
错误处理的流程，和异常应该好好再考虑一下
把异常处理完之后，把代码好好整理整理，再往事务发件箱上面去调整

2020-11-11:

发现pika线程的问题，造成了异常。而且影响到了数据库的session。
使用线程安全的方式后，pika发送消息的确认就和事务分离了。所以最后还是要考虑事务性发件箱的模式

2020-11-10:

self.database_facade.add_task(tasks)
self.event_facade.send_task(tasks)
self.database_facade.commit()

# 上面这个样子，commit后线程挂了，那么就没有事件发送出来，流程就停住了
# 下面的方式，有个问题，如果消息先被处理了，而commit还没有做完，接收端可能拿不到正确的数据

self.database_facade.add_task(tasks)
self.database_facade.commit()
self.event_facade.send_task(tasks)

# 事务性发件箱模式，看来还是最成熟的方式

先按照第一种方式，把整个流程过一下
然后把消息的发送改成事件发件箱模式


2020-10-20:
经过了一段时间的考虑，大致决定了用哪些工具，现在需要把概念转换到代码上面


2020-10-20 之前:

# 在docker上跑一个数据库用来测试
docker run --name some-mysql -v /opt/zhangyang/mysql/db1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=zhang -d mysql
docker run -it --rm mysql mysql -uroot -p

docker run --name some-mysql -v /opt/zhangyang/mysql/db2:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=zhang -d mysql:5
docker run -it --rm mysql:5 mysql -h10.19.17.188 -P3306 -uroot -pzhang

# perfect workerflow engine，也许可以参考一下
https://docs.prefect.io


uvicorn job_model_server:app --port 12345 --no-access-log

uvicorn job_model_server:app --port 12345 --no-access-log --workers 10 --lifespan off
